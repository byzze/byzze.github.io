<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Byzze</title>
    <link>https://byzze.github.io/post/</link>
    <description>Recent content in Posts on Byzze</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Jun 2023 11:00:05 +0800</lastBuildDate><atom:link href="https://byzze.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>理解Raft协议</title>
      <link>https://byzze.github.io/post/raft/</link>
      <pubDate>Thu, 08 Jun 2023 11:00:05 +0800</pubDate>
      
      <guid>https://byzze.github.io/post/raft/</guid>
      <description>Raft是什么 共识是什么 CAP理论 Raft能做什么 Raft的原理 Leader选举机制 日志同步 总结 Raft是什么 Raft 是一种共识算法，旨在易于理解。它在容错性和性能方面与 Paxos 相当。不同之处在于，Raft 被分解为相对独立的子问题，并且它清晰地解决了实际系统所需的所有主要部分。目前有不少的应用都是采用Raft协议来保证集群节点一致性，比如ectd，consul
共识是什么 共识通常出现在复制状态机的背景下，这是构建容错系统的一种通用方法。每个服务器都有一个状态机和一个日志。状态机是我们想要使其容错的组件，例如散列表。对于客户端来说，他们将与一个可靠的单个状态机进行交互，即使群集中的一小部分服务器发生故障。每个状态机从其日志中接受命令作为输入。在我们的散列表示例中，日志将包括像将 x 设置为 3 的命令。共识算法用于在服务器的日志中达成命令的一致。共识算法必须确保如果任何一个状态机将第 n 个命令设置 x 为 3，那么没有其他状态机将会应用不同的第 n 个命令。因此，每个状态机处理相同的一系列命令，从而产生相同的一系列结果并到达相同的一系列状态。
即共识在分布式系统下通过复制log的机制，相互通信，确保多台机器下的数据一致性
CAP理论 CAP理论是指分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三者只能满足其中的两个，无法同时满足三个特性。该理论由加州大学伯克利分校的计算机科学家Eric Brewer于2000年提出。
一致性指的是分布式系统中的所有节点，在同一时刻看到的数据都应该是一致的。可用性则指的是分布式系统应该保证在任何时候都能够对外提供服务，而分区容错性则是指分布式系统在遭遇网络分区的情况下，仍然能够保持数据的一致性和可用性。
CAP理论认为，在一个分布式系统中，由于网络不可靠或节点故障等原因，系统可能会遭受分区的情况。因此，在这种情况下，我们必须要舍弃一些特性，以保证系统的可用性以及一致性。
在实际开发中，选择一致性、可用性、分区容错性中的两个，将会依据项目本身的需求。例如，针对分布式缓存系统，对于短时间内的数据不一致可以容忍，可用性和分区容错性显得尤为重要；而对于金融行业的分布式交易系统，则需要最高级的数据一致性保障。
Raft能做什么 通过Raft可以用来构建容错系统。在一个容错系统中，如果有一些节点出现故障，仍然可以保证系统正常运行。Raft协议可以用来确保分布式系统中的每个节点都拥有相同的状态。
Raft的原理 Raft将一个节点分为三中状态
Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后高速Follower提交日志。 Follower：接受并持久化Leader同步的日志，在Leader告知日志可以提交后，提交日志。当Leader出现故障时，主动推荐自己为候选人。 Candidate：Leader选举过程中的临时角色。向其他节点发送请求投票信息，如果获得大多数选票，则晋升为Leader。 Leader选举机制 所有的节点一开始处于选举时间（随机超时时间），处于Follower状态 当其中一个节点先到完成选择时间时，将由Follower转为Candidate，并向其他节点请求投票，投票自己成为Leader，当收到的投票数超过了半数（Candidate/2+1）,则可以转换为Leader，任期（Term）数为2 成为Leader之后，会持续周期性向其他节点发送heartbeat 当Follower收到heartbeat后，会重置选举时间，如果在执行完选举时间时，还未收到heartbeat，则Follower就会转为Candidate，重新进入选举Leader，并增加任期（Term）数 原来的Leader恢复状态之后，收到了新Leader的heartbeat，通过任期数（Term）判断已经产生了新的Leader，就会将自己的状态由Leader转为Follower 日志同步 Raft算法实现日志同步的具体过程如下：
Leader处理客户端的请求，将数据封装，并追加到自己的日志中 Leader并行地向系统中所有节点发送日志复制消息 接收到消息的节点确认消息没有问题，则将数据追加到自己的日志中，并向Leader返回ACK表示接收成功 Leader若在随机超时时间内收到大多数节点的ACK,，将该数据应用到状态机并向客户端返回成功 总结 选举Leader时，采用了随机超时时间控制，先超时的先进入Candidate竞选Leader，但是如果出现了相同时间进入Candidate，且获取的选票一致时，则会重新进入竞选状态。 选举倒计时timeout通常是 150ms ~ 300ms 直接的某个随机值 在集群中如果出现了脑裂问题时，出现了网络分区，会出现多个Leader，但是由于分区导致始终有一个Leader所在的分区节点数占大部分，其余Leader所在节点处于小部分，从而导致处于小部分节点分区的Leader得不到大部分节点的ACK响应，数据无法正常Commit。直到网络正常时，多个Leader出现的时候，对比他们的term即任期（上面的步长），新的为Leader，之前小部分Leader未提交的数据则都会被舍弃，关于为什么要舍弃这些数据，需要使用CAP理论解释。 数据的流向只能从 Leader 节点向 Follower 节点转移 数据在大多数节点提交后才commit，并向客户端响应成功 参考链接</description>
    </item>
    
    <item>
      <title>Wireshark入门</title>
      <link>https://byzze.github.io/post/wireshark/</link>
      <pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/wireshark/</guid>
      <description>入门记录 使用https无法抓取请求：https://blog.51cto.com/u_15672212/5383275 使用教程：https://www.cnblogs.com/mq0036/p/11187138.html
数据包详细信息 TCP包详细信息 Wireshark 存在两种过滤器 1）抓包过滤器 2）显示过滤器
使用过滤器加上过滤字段提取我们想要数据 TCP三次握手 icmp 互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。
ICMP [1]依靠IP来完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了 ping 和 traceroute 这两个特别的例子。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。
小结 使用抓包分析，可以了解到网络连接的详细过程</description>
    </item>
    
    <item>
      <title>Go-callvis Go代码调用链路可视化工具</title>
      <link>https://byzze.github.io/post/go-callvis/</link>
      <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/go-callvis/</guid>
      <description>go-callvis 与链路追踪（Tracing）不同，Tracing主要关注复杂的是分布式环境中各个服务节点间的调用关系，主要用于服务治理。而我们本次探索的代码调用链路则是代码方法级别的调用关系，主要用于代码设计。 可视化工具可以将代码间的调用关系通过图表的方式展示出来，如下图: 来自go-callvis工具 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( &amp;#34;flag&amp;#34; &amp;#34;log&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;os&amp;#34; &amp;#34;runtime/pprof&amp;#34; ) var cpuprofile = flag.</description>
    </item>
    
    <item>
      <title>Go语言自带的分析性能工具pprof</title>
      <link>https://byzze.github.io/post/golang-pprof/</link>
      <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/golang-pprof/</guid>
      <description>Go 语言内置库里就自带了性能分析库 pprof。pprof 有两个包用来分析程序： runtime/pprof 与 net/http/pprof，其中 net/http/pprof 只是对 runtime/pprof 包进行封装并用 http 暴露出来。runtime/pprof 用于对普通的应用程序进行性能分析，主要用于可结束的代码块，比如一次函数调用；而 net/http/pprof 专门用于对后台服务型程序的性能采集与分析。
runtime/pprof 代码块
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( &amp;#34;flag&amp;#34; &amp;#34;log&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;os&amp;#34; &amp;#34;runtime/pprof&amp;#34; ) var cpuprofile = flag.</description>
    </item>
    
    <item>
      <title>Linux 命令记录 🙈</title>
      <link>https://byzze.github.io/post/linux_use/</link>
      <pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/linux_use/</guid>
      <description>命令 说明 find / -name stdout.log 查找文件 ufw status 查看防火墙 ln -s [源文件或目录] [目标文件或目录] 软连接 chmod -v u+w /etc/sudoers 赋予写权限 chmod -v u-w /etc/sudoers 收回写权限 sudo usermod -aG docker $USER 添加用户到用户组 newgrp docker 登入docker群组，使配置生效 uname -a 查看内核/操作系统/CPU信息 head -n 1 /etc/issue 查看操作系统版本 cat /proc/cpuinfo 查看CPU信息 hostname 查看计算机名 lspci -tv 列出所有PCI设备 lsusb -tv 列出所有USB设备 lsmod 列出加载的内核模块 env 查看环境变量资源 free -m 查看内存使用量和交换区使用量 df -h 查看各分区使用情况 du -sh &amp;lt;目录名&amp;gt; 查看指定目录的大小 grep MemTotal /proc/meminfo 查看内存总量 grep MemFree /proc/meminfo 查看空闲内存量 uptime 查看系统运行时间、用户数、负载 cat /proc/loadavg 查看系统负载磁盘和分区 mount column -t fdisk -l 查看所有分区 swapon -s 查看所有交换分区 hdparm -i /dev/hda 查看磁盘参数(仅适用于IDE设备) dmesg grep IDE ifconfig 查看所有网络接口的属性 iptables -L 查看防火墙设置 route -n 查看路由表 netstat -lntp 查看所有监听端口 netstat -antp 查看所有已经建立的连接 netstat -s 查看网络统计信息进程 ps -ef 查看所有进程 top 实时显示进程状态用户 w 查看活动用户 id &amp;lt;用户名&amp;gt; 查看指定用户信息 last 查看用户登录日志 cut -d: -f1 /etc/passwd 查看系统所有用户 cut -d: -f1 /etc/group 查看系统所有组 crontab -l 查看当前用户的计划任务服务 chkconfig –list 列出所有系统服务 chkconfig –list grep on rpm -qa 查看所有安装的软件包 参考链接：https://blog.</description>
    </item>
    
    <item>
      <title>Minikube 安装过程</title>
      <link>https://byzze.github.io/post/minikube/</link>
      <pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/minikube/</guid>
      <description>安装kubectl 在 Linux 系统中安装并设置 kubectl | Kubernetes
安装minikube 官方教程:minikube start | minikube (k8s.io) 简书教程：https://www.jianshu.com/p/2eb952ffe89b 使用国内镜像:Minikube 一键开启国内镜像加速 (xintech.co)
启动命令
1 2 3 4 5 6 7 8 9 10 minikube start --driver=docker --container-runtime=containerd --image-mirror-country=cn # 国外服务器 minikube start # 使用阿里云版本时，指定国内源 minikube start --image-mirror-country=cn # 使用阿里云版本时，指定镜像源 minikube start --image-mirror=registry.cn-hangzhou.aliyuncs.com/google_containers 1 2 3 Minikube 一键开启国内镜像加速:https://blog.xintech.co/minikube-yi-jian-kai-qi-guo-nei-jing-xiang-jia-su/ Minikube didnt start:https://github.com/kubernetes/minikube/issues/14477 minikube轻松搭建一个:https://colobu.com/2022/06/02/setup-a-k8s-cluster-with-minikube/ 创建镜像使用阿里云，官方教程拉取会失败 Kubernetes 环境搭建：https://www.cnblogs.com/cjsblog/p/11877014.html 指定镜像启动pod：kubectl create deployment hello-minikube --image=registry.cn-hangzhou.aliyuncs.com/google_containers/echoserver:1.10 查看插件：minikube addons list 使用某个插件：minikube addons enable ingress</description>
    </item>
    
    <item>
      <title>博客网站</title>
      <link>https://byzze.github.io/post/first/</link>
      <pubDate>Fri, 11 Nov 2022 16:20:35 +0800</pubDate>
      
      <guid>https://byzze.github.io/post/first/</guid>
      <description>第一个博客网站 下载hugo 确保已经安装了go语言环境 在终端执行命令go install github.com/gohugoio/hugo@latest 安装成功 创建网站，引入主题 1 2 3 4 5 6 mkdir ~/hugo cd ~/hugo hugo new site blog cd blog git submodule add &amp;lt;https://github.com/WingLim/hugo-tania&amp;gt; themes/hugo-tania 步骤 git submodule 执行失败两点问题** https请求修改为项目的git@请求 在个人github创建对应仓库 blog ，初始化，push相关操作 参考地址：https://themes.gohugo.io/themes/hugo-tania/ 启动服务 1 hugo server 访问地址 http://localhost:1313/
部署github https://www.gohugo.org/
1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add -A git commit -m &amp;#34;first commit&amp;#34; git push -u origin master 若https的github不能正常访问，改用git@github.</description>
    </item>
    
    <item>
      <title>Markdown Syntax Guide</title>
      <link>https://byzze.github.io/post/markdown-syntax/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/markdown-syntax/</guid>
      <description>&lt;p&gt;This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Placeholder Text</title>
      <link>https://byzze.github.io/post/placeholder-text/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://byzze.github.io/post/placeholder-text/</guid>
      <description>&lt;p&gt;Lorem est tota propiore conpellat pectoribus de pectora summo.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
