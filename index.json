[{"categories":null,"contents":"","date":"Jan 13","permalink":"https://byzze.github.io/projects/b_project/","tags":null,"title":"gotool"},{"categories":null,"contents":"","date":"Nov 26","permalink":"https://byzze.github.io/projects/a_project/","tags":null,"title":"Hugo Tania Theme"},{"categories":null,"contents":" Raft是什么 共识是什么 CAP理论 Raft能做什么 Raft的原理 Leader选举机制 日志同步 总结 Raft是什么 Raft 是一种共识算法，旨在易于理解。它在容错性和性能方面与 Paxos 相当。不同之处在于，Raft 被分解为相对独立的子问题，并且它清晰地解决了实际系统所需的所有主要部分。目前有不少的应用都是采用Raft协议来保证集群节点一致性，比如ectd，consul\n共识是什么 共识通常出现在复制状态机的背景下，这是构建容错系统的一种通用方法。每个服务器都有一个状态机和一个日志。状态机是我们想要使其容错的组件，例如散列表。对于客户端来说，他们将与一个可靠的单个状态机进行交互，即使群集中的一小部分服务器发生故障。每个状态机从其日志中接受命令作为输入。在我们的散列表示例中，日志将包括像将 x 设置为 3 的命令。共识算法用于在服务器的日志中达成命令的一致。共识算法必须确保如果任何一个状态机将第 n 个命令设置 x 为 3，那么没有其他状态机将会应用不同的第 n 个命令。因此，每个状态机处理相同的一系列命令，从而产生相同的一系列结果并到达相同的一系列状态。\n即共识在分布式系统下通过复制log的机制，相互通信，确保多台机器下的数据一致性\nCAP理论 CAP理论是指分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三者只能满足其中的两个，无法同时满足三个特性。该理论由加州大学伯克利分校的计算机科学家Eric Brewer于2000年提出。\n一致性指的是分布式系统中的所有节点，在同一时刻看到的数据都应该是一致的。可用性则指的是分布式系统应该保证在任何时候都能够对外提供服务，而分区容错性则是指分布式系统在遭遇网络分区的情况下，仍然能够保持数据的一致性和可用性。\nCAP理论认为，在一个分布式系统中，由于网络不可靠或节点故障等原因，系统可能会遭受分区的情况。因此，在这种情况下，我们必须要舍弃一些特性，以保证系统的可用性以及一致性。\n在实际开发中，选择一致性、可用性、分区容错性中的两个，将会依据项目本身的需求。例如，针对分布式缓存系统，对于短时间内的数据不一致可以容忍，可用性和分区容错性显得尤为重要；而对于金融行业的分布式交易系统，则需要最高级的数据一致性保障。\nRaft能做什么 通过Raft可以用来构建容错系统。在一个容错系统中，如果有一些节点出现故障，仍然可以保证系统正常运行。Raft协议可以用来确保分布式系统中的每个节点都拥有相同的状态。\nRaft的原理 Raft将一个节点分为三中状态\nLeader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后高速Follower提交日志。 Follower：接受并持久化Leader同步的日志，在Leader告知日志可以提交后，提交日志。当Leader出现故障时，主动推荐自己为候选人。 Candidate：Leader选举过程中的临时角色。向其他节点发送请求投票信息，如果获得大多数选票，则晋升为Leader。 Leader选举机制 所有的节点一开始处于选举时间（随机超时时间），处于Follower状态 当其中一个节点先到完成选择时间时，将由Follower转为Candidate，并向其他节点请求投票，投票自己成为Leader，当收到的投票数超过了半数（Candidate/2+1）,则可以转换为Leader，任期（Term）数为2 成为Leader之后，会持续周期性向其他节点发送heartbeat 当Follower收到heartbeat后，会重置选举时间，如果在执行完选举时间时，还未收到heartbeat，则Follower就会转为Candidate，重新进入选举Leader，并增加任期（Term）数 原来的Leader恢复状态之后，收到了新Leader的heartbeat，通过任期数（Term）判断已经产生了新的Leader，就会将自己的状态由Leader转为Follower 日志同步 Raft算法实现日志同步的具体过程如下：\nLeader处理客户端的请求，将数据封装，并追加到自己的日志中 Leader并行地向系统中所有节点发送日志复制消息 接收到消息的节点确认消息没有问题，则将数据追加到自己的日志中，并向Leader返回ACK表示接收成功 Leader若在随机超时时间内收到大多数节点的ACK,，将该数据应用到状态机并向客户端返回成功 总结 选举Leader时，采用了随机超时时间控制，先超时的先进入Candidate竞选Leader，但是如果出现了相同时间进入Candidate，且获取的选票一致时，则会重新进入竞选状态。 选举倒计时timeout通常是 150ms ~ 300ms 直接的某个随机值 在集群中如果出现了脑裂问题时，出现了网络分区，会出现多个Leader，但是由于分区导致始终有一个Leader所在的分区节点数占大部分，其余Leader所在节点处于小部分，从而导致处于小部分节点分区的Leader得不到大部分节点的ACK响应，数据无法正常Commit。直到网络正常时，多个Leader出现的时候，对比他们的term即任期（上面的步长），新的为Leader，之前小部分Leader未提交的数据则都会被舍弃，关于为什么要舍弃这些数据，需要使用CAP理论解释。 数据的流向只能从 Leader 节点向 Follower 节点转移 数据在大多数节点提交后才commit，并向客户端响应成功 参考链接\nhttps://juejin.cn/post/7143541597165060109 http://thesecretlivesofdata.com/raft/ https://here2say.com/44/ https://raft.github.io/ ","date":"Jun 08","permalink":"https://byzze.github.io/post/raft/","tags":null,"title":"理解Raft协议"},{"categories":["math"],"contents":" 入门记录 使用https无法抓取请求：https://blog.51cto.com/u_15672212/5383275 使用教程：https://www.cnblogs.com/mq0036/p/11187138.html\n数据包详细信息 TCP包详细信息 Wireshark 存在两种过滤器 1）抓包过滤器 2）显示过滤器\n使用过滤器加上过滤字段提取我们想要数据 TCP三次握手 icmp 互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。\nICMP [1]依靠IP来完成它的任务，它是IP的主要部分。它与传输协议（如TCP和UDP）显著不同：它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了 ping 和 traceroute 这两个特别的例子。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。\n小结 使用抓包分析，可以了解到网络连接的详细过程\n","date":"May 24","permalink":"https://byzze.github.io/post/wireshark/","tags":null,"title":"Wireshark入门"},{"categories":null,"contents":"https://github.com/ofabry/go-callvis 与链路追踪（Tracing）不同，Tracing关注复杂的分布式环境中各个服务节点间的调用关系，主要用于服务治理。而我们本次探索的代码调用链路则是代码方法级别的调用关系，主要用于代码设计。 可视化工具可以将代码间的调用关系通过图表的方式展示出来，如下图（来自go-callvis工具） 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( \u0026#34;flag\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime/pprof\u0026#34; ) var cpuprofile = flag.Bool(\u0026#34;cpu\u0026#34;, false, \u0026#34;write cpu profile to file\u0026#34;) var memprofile = flag.Bool(\u0026#34;mem\u0026#34;, false, \u0026#34;write cpu profile to file\u0026#34;) func main() { flag.Parse() // 创建cpu分析文件 if *cpuprofile { f, err := os.Create(\u0026#34;./main-cpu.prof\u0026#34;) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } SimulationAlloc() // 创建内存分析文件,放在后面才能采集到内存分配信息 if *memprofile { f, err := os.Create(\u0026#34;./main-mem.prof\u0026#34;) if err != nil { log.Fatal(err) } pprof.WriteHeapProfile(f) f.Close() } } // SimulationAlloc 模拟分配内存 func SimulationAlloc() string { s := \u0026#34;\u0026#34; for i := 0; i \u0026lt; 100; i++ { for j := 0; j \u0026lt; 10; j++ { s += randomString(1000) } } return s } const letterBytes = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } go-callvis main.go 执行命令会出现host地址,浏览器打开即可显示 go-callvis -nostb main.go 不显示标准库 go-callvis /pacpage 指定package go-callvis -tests /pacpage 指定test package\n","date":"May 04","permalink":"https://byzze.github.io/post/go-callvis/","tags":["markdown","text"],"title":"Go-callvis Go代码调用链路可视化工具"},{"categories":null,"contents":"Go 语言内置库里就自带了性能分析库 pprof。pprof 有两个包用来分析程序： runtime/pprof 与 net/http/pprof，其中 net/http/pprof 只是对 runtime/pprof 包进行封装并用 http 暴露出来。runtime/pprof 用于对普通的应用程序进行性能分析，主要用于可结束的代码块，比如一次函数调用；而 net/http/pprof 专门用于对后台服务型程序的性能采集与分析。\nruntime/pprof 代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import ( \u0026#34;flag\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime/pprof\u0026#34; ) var cpuprofile = flag.Bool(\u0026#34;cpu\u0026#34;, false, \u0026#34;write cpu profile to file\u0026#34;) var memprofile = flag.Bool(\u0026#34;mem\u0026#34;, false, \u0026#34;write cpu profile to file\u0026#34;) func main() { flag.Parse() // 创建cpu分析文件 if *cpuprofile { f, err := os.Create(\u0026#34;./main-cpu.prof\u0026#34;) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } SimulationAlloc() // 创建内存分析文件,放在后面才能采集到内存分配信息 if *memprofile { f, err := os.Create(\u0026#34;./main-mem.prof\u0026#34;) if err != nil { log.Fatal(err) } pprof.WriteHeapProfile(f) f.Close() } } // SimulationAlloc 模拟分配内存 func SimulationAlloc() string { s := \u0026#34;\u0026#34; for i := 0; i \u0026lt; 100; i++ { for j := 0; j \u0026lt; 10; j++ { s += randomString(1000) } } return s } const letterBytes = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } go build -o main main.go 构建程序 ./main -cpu -mem 执行之后在当前文件夹生成main-cpu.prof, main-mem.prof文件\n分析数据 浏览器(推荐) go tool pprof -http=:端口号 生成的分析文件 界面视图 火焰图视图 分析耗时的方法名 源码视图 可以查看到43行耗时的代码 cpu分析 go tool pprof -http=:9999 main-cpu.prof 浏览器打开cpu分析文件, 箭头线上的数字代表执行耗时 cpu分析文件部分截图 mem分析 go tool pprof -http=:9998 main-mem.prof 浏览器打开mem分析文件, 箭头线上的数字代表分配内存 mem分析文件部分截图 终端命令 go tool pprof main main-cpu.prof\n上图中，其他的一些参数解释如下：\nDuration：程序执行时间。多核执行程序，总计耗时 301.35ms，而采样时间为 150ms,假设有3核执-行该程序,则平均每个核采样50ms数据。 flat/flat%：分别表示在当前层级cpu的占用时间和百分比。例如runtime.memmove在当前层级占用cpu时间60ms，占比本次采集时间的40%。 cum/cum%：分别表示截止到当前层级累积的cpu时间和占比。例如main.SimulationAlloc累积占用时间70ms，占本次采集时间的46.67%。 sum%：所有层级的 CPU 时间累积占用，从小到大一直累积到100%,即150ms. (pprof)：命令行提示, 使用help查看更多。表示当前在go tool 的pprof工具命令行中, go tool还包括cgo、doc、pprof、test2json、trace等多种命令 top5 -cum 按cum条件列出前5个,可以发现途中main.SimulationAlloc占用最多\nlist main.SimulationAlloc 可以查看源码和执行信息,可以查看得知代码在43行耗时最多\nnet/http/pprof 分析web服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net/http\u0026#34; _ \u0026#34;net/http/pprof\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, SimulationAlloc) http.ListenAndServe(\u0026#34;:6060\u0026#34;, nil) } // SimulationAlloc 模拟分配内存 func SimulationAlloc(w http.ResponseWriter, r *http.Request) { s := \u0026#34;\u0026#34; for i := 0; i \u0026lt; 100; i++ { for j := 0; j \u0026lt; 10; j++ { s += randomString(1000) } } fmt.Println(s) } const letterBytes = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 运行程序,分析结果\n1 2 3 4 go run main.go go tool pprof http://localhost:6060/debug/pprof/profile\\?seconds\\=30 #新开终端执行分析 cpu 执行top5 -cum 查看耗时方法 执行list main.SimulationAlloc 定位耗时方法,处于第20行的代码 也可以通过执行svg在当前文件下生成svg文件或使用web,使用浏览器打开查看\n因为web服务没有创建分析文件,需要执行go tool pprof http://localhost:6060/debug/pprof/profile\\?seconds\\=10 -output 同时执行wrk -c 10 -t 2 -d 10s http://localhost:6060/ 发起请求,收集数据分析,生成的文件自动Saved 执行go tool pprof -http=:9999 xxxx.pb.gz在浏览器打开分析数据(火焰图, 图表等)\n更多操作, 参考：https://pkg.go.dev/net/http/pprof#hdr-Usage_examples 使用 pprof 工具查看堆剖析：\ngo tool pprof http://localhost:6060/debug/pprof/heap 如果要查看 30 秒的 CPU 剖析：\ngo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30 如果要查看 goroutine 阻塞情况的剖析，在程序中调用 runtime.SetBlockProfileRate 后：\ngo tool pprof http://localhost:6060/debug/pprof/block 如果要查看互斥锁争用的持有者，在程序中调用 runtime.SetMutexProfileFraction 后：\ngo tool pprof http://localhost:6060/debug/pprof/mutex 该包还导出一个处理程序，为 \u0026ldquo;go tool trace\u0026rdquo; 命令提供执行跟踪数据。要收集 5 秒钟的执行跟踪：\ncurl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5 go tool trace trace.out\n总结 例子：使用go-callvis 执行go代码，获取程序调用链，加载过程中出现比较慢的情况，需要对go-callvis进行分析，分析性能瓶颈\nTrace 参考：https://tonybai.com/2021/06/28/understand-go-execution-tracer-by-example/\n","date":"May 04","permalink":"https://byzze.github.io/post/golang-pprof/","tags":["markdown","text"],"title":"Go语言自带的分析性能工具pprof"},{"categories":["syntax"],"contents":" 命令 说明 find / -name stdout.log 查找文件 ufw status 查看防火墙 ln -s [源文件或目录] [目标文件或目录] 软连接 chmod -v u+w /etc/sudoers 赋予写权限 chmod -v u-w /etc/sudoers 收回写权限 sudo usermod -aG docker $USER 添加用户到用户组 newgrp docker 登入docker群组，使配置生效 uname -a 查看内核/操作系统/CPU信息 head -n 1 /etc/issue 查看操作系统版本 cat /proc/cpuinfo 查看CPU信息 hostname 查看计算机名 lspci -tv 列出所有PCI设备 lsusb -tv 列出所有USB设备 lsmod 列出加载的内核模块 env 查看环境变量资源 free -m 查看内存使用量和交换区使用量 df -h 查看各分区使用情况 du -sh \u0026lt;目录名\u0026gt; 查看指定目录的大小 grep MemTotal /proc/meminfo 查看内存总量 grep MemFree /proc/meminfo 查看空闲内存量 uptime 查看系统运行时间、用户数、负载 cat /proc/loadavg 查看系统负载磁盘和分区 mount column -t fdisk -l 查看所有分区 swapon -s 查看所有交换分区 hdparm -i /dev/hda 查看磁盘参数(仅适用于IDE设备) dmesg grep IDE ifconfig 查看所有网络接口的属性 iptables -L 查看防火墙设置 route -n 查看路由表 netstat -lntp 查看所有监听端口 netstat -antp 查看所有已经建立的连接 netstat -s 查看网络统计信息进程 ps -ef 查看所有进程 top 实时显示进程状态用户 w 查看活动用户 id \u0026lt;用户名\u0026gt; 查看指定用户信息 last 查看用户登录日志 cut -d: -f1 /etc/passwd 查看系统所有用户 cut -d: -f1 /etc/group 查看系统所有组 crontab -l 查看当前用户的计划任务服务 chkconfig –list 列出所有系统服务 chkconfig –list grep on rpm -qa 查看所有安装的软件包 参考链接：https://blog.csdn.net/qq_31278903/article/details/83146031 ","date":"Jan 13","permalink":"https://byzze.github.io/post/linux_use/","tags":null,"title":"Linux 命令记录 🙈"},{"categories":["math"],"contents":" 安装kubectl 在 Linux 系统中安装并设置 kubectl | Kubernetes\n安装minikube 官方教程:minikube start | minikube (k8s.io) 简书教程：https://www.jianshu.com/p/2eb952ffe89b 使用国内镜像:Minikube 一键开启国内镜像加速 (xintech.co)\n启动命令\n1 2 3 4 5 6 7 8 9 10 minikube start --driver=docker --container-runtime=containerd --image-mirror-country=cn # 国外服务器 minikube start # 使用阿里云版本时，指定国内源 minikube start --image-mirror-country=cn # 使用阿里云版本时，指定镜像源 minikube start --image-mirror=registry.cn-hangzhou.aliyuncs.com/google_containers 1 2 3 Minikube 一键开启国内镜像加速:https://blog.xintech.co/minikube-yi-jian-kai-qi-guo-nei-jing-xiang-jia-su/ Minikube didnt start:https://github.com/kubernetes/minikube/issues/14477 minikube轻松搭建一个:https://colobu.com/2022/06/02/setup-a-k8s-cluster-with-minikube/ 创建镜像使用阿里云，官方教程拉取会失败 Kubernetes 环境搭建：https://www.cnblogs.com/cjsblog/p/11877014.html 指定镜像启动pod：kubectl create deployment hello-minikube --image=registry.cn-hangzhou.aliyuncs.com/google_containers/echoserver:1.10 查看插件：minikube addons list 使用某个插件：minikube addons enable ingress\n安装docker 官网安装：https://docs.docker.com/engine/install/ubuntu/ Install Docker Desktop on Ubuntu | Docker Documentation\n如何在Ubuntu上安装使用Docker - 腾讯云开发者社区-腾讯云 (tencent.com)\nwsl 启动命令sudo service docker start\n","date":"Jan 13","permalink":"https://byzze.github.io/post/minikube/","tags":null,"title":"Minikube 安装过程"},{"categories":null,"contents":" 第一个博客网站 下载hugo 确保已经安装了go语言环境 在终端执行命令go install github.com/gohugoio/hugo@latest 安装成功 创建网站，引入主题 1 2 3 4 5 6 mkdir ~/hugo cd ~/hugo hugo new site blog cd blog git submodule add \u0026lt;https://github.com/WingLim/hugo-tania\u0026gt; themes/hugo-tania 步骤 git submodule 执行失败两点问题** https请求修改为项目的git@请求 在个人github创建对应仓库 blog ，初始化，push相关操作 参考地址：https://themes.gohugo.io/themes/hugo-tania/ 启动服务 1 hugo server 访问地址 http://localhost:1313/\n部署github https://www.gohugo.org/\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add -A git commit -m \u0026#34;first commit\u0026#34; git push -u origin master 若https的github不能正常访问，改用git@github.com:username/username.github.io.git\n","date":"Nov 11","permalink":"https://byzze.github.io/post/first/","tags":null,"title":"博客网站"},{"categories":null,"contents":"","date":"Nov 11","permalink":"https://byzze.github.io/home/","tags":null,"title":"Home"},{"categories":["themes","syntax"],"contents":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Mar 11","permalink":"https://byzze.github.io/post/markdown-syntax/","tags":["markdown","css","html"],"title":"Markdown Syntax Guide"},{"categories":null,"contents":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"Mar 09","permalink":"https://byzze.github.io/post/placeholder-text/","tags":["markdown","text"],"title":"Placeholder Text"},{"categories":null,"contents":"Here is a byzze about.\n","date":"Jan 01","permalink":"https://byzze.github.io/about/","tags":null,"title":""},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://byzze.github.io/articles/","tags":null,"title":"Articles"}]